[
     {
          "algorithm": "A novel algorithm named \"Randomized Greedy with Local Search\" (RGLS) that selects the next node by first choosing a random unvisited node, then performing a local search around the selected node to find a better candidate if possible.",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Step 1: Randomly select an unvisited node\n    next_node = random.choice(unvisited_nodes)\n    \n    # Step 2: Perform local search to find a better candidate\n    best_distance = distance_matrix[current_node, next_node]\n    for neighbor in unvisited_nodes:\n        if neighbor != next_node:\n            distance = distance_matrix[current_node, neighbor]\n            if distance < best_distance:\n                best_distance = distance\n                next_node = neighbor\n    \n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that selects the next node based on a combination of the nearest neighbor heuristic and a random perturbation to explore alternative paths.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Nearest neighbor heuristic\n    min_distance = np.inf\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node, node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    \n    # Random perturbation to explore alternative paths\n    if len(unvisited_nodes) > 1:\n        random_node = np.random.choice(unvisited_nodes)\n        random_distance = distance_matrix[current_node, random_node]\n        if np.random.rand() < 0.1 and random_distance < min_distance * 1.5:  # Adjust the threshold as needed\n            next_node = random_node\n    \n    return next_node",
          "objective": 6.63772,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: \"Probabilistic Greedy with Adaptive Threshold for TSP\", Main steps: Calculate the probability of selecting each unvisited node based on the ratio of its distance to the minimum distance, adaptively adjust the threshold based on the number of unvisited nodes, and select the next node probabilistically using the adjusted threshold.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate the minimum distance\n    min_distance = np.min(distance_matrix[current_node, unvisited_nodes])\n    \n    # Calculate the probability of selecting each unvisited node\n    probabilities = distance_matrix[current_node, unvisited_nodes] / (min_distance + 1e-10)\n    probabilities /= np.sum(probabilities)\n    \n    # Adaptively adjust the threshold based on the number of unvisited nodes\n    threshold = 1.0 - (len(unvisited_nodes) - 1) / len(unvisited_nodes)\n    \n    # Select the next node probabilistically using the adjusted threshold\n    next_node = np.random.choice(unvisited_nodes, p=probabilities) if np.random.rand() < threshold else unvisited_nodes[np.argmin(probabilities)]\n    \n    return next_node",
          "objective": 7.17944,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that selects the next node based on a combination of the nearest neighbor heuristic, a random perturbation to explore alternative paths, and a consideration of the distance from the destination node.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Nearest neighbor heuristic\n    min_distance = np.inf\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node, node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    \n    # Random perturbation to explore alternative paths\n    if len(unvisited_nodes) > 1:\n        random_node = np.random.choice(unvisited_nodes)\n        random_distance = distance_matrix[current_node, random_node]\n        if np.random.rand() < 0.1 and random_distance < min_distance * 1.5:  # Adjust the threshold as needed\n            next_node = random_node\n    \n    # Consideration of the distance from the destination node\n    if next_node is not None:\n        destination_distance = distance_matrix[next_node, destination_node]\n        alternative_node = np.argmin(distance_matrix[unvisited_nodes, destination_node])\n        alternative_distance = distance_matrix[unvisited_nodes[alternative_node], destination_node]\n        if np.random.rand() < 0.1 and alternative_distance < destination_distance:\n            next_node = unvisited_nodes[alternative_node]\n    \n    return next_node",
          "objective": 8.16381,
          "other_inf": null
     }
]