[
     {
          "algorithm": "Algorithm: \"Greedy Randomized Adaptive Search Procedure (GRASP) for TSP\"",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Create a list of candidate nodes with their distances from the current node\n    candidates = [(node, distance_matrix[current_node, node]) for node in unvisited_nodes]\n    \n    # Calculate the lower and upper bound for the restricted candidate list\n    lower_bound = min(candidates, key=lambda x: x[1])[1]\n    upper_bound = max(candidates, key=lambda x: x[1])[1]\n    \n    # Create a restricted candidate list (RCL) with nodes within a random alpha range\n    alpha = random.uniform(0, 1)\n    rcl = [node for node, dist in candidates if lower_bound <= dist <= alpha * (upper_bound - lower_bound) + lower_bound]\n    \n    # Select the next node from the RCL randomly\n    next_node = random.choice(rcl)\n    \n    return next_node",
          "objective": 16.08229,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: \"Probabilistic Weighted Random Selection for TSP\"",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate the probabilities based on the inverse of the distances\n    probabilities = 1 / distance_matrix[current_node, unvisited_nodes]\n    probabilities /= np.sum(probabilities)  # Normalize probabilities\n\n    # Select the next node based on the calculated probabilities\n    next_node = np.random.choice(unvisited_nodes, p=probabilities)\n    \n    return next_node",
          "objective": 18.38329,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: \"Adaptive Probabilistic Weighted Random Selection for TSP\" - Main steps: Calculate probabilities based on inverse distances and a dynamic weight factor that decreases with each iteration, normalize probabilities, and select the next node using the weighted probabilities.",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate a dynamic weight factor that decreases with each iteration\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    \n    # Calculate the probabilities based on the inverse of the distances and the weight factor\n    probabilities = weight_factor / distance_matrix[current_node, unvisited_nodes]\n    probabilities /= np.sum(probabilities)  # Normalize probabilities\n\n    # Select the next node based on the calculated probabilities\n    next_node = np.random.choice(unvisited_nodes, p=probabilities)\n    \n    return next_node",
          "objective": 18.60668,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named \"Adaptive Randomized Greedy\", starts by calculating the shortest distance from the current node to each unvisited node, then selects the next node based on a weighted probability distribution that favors nodes closer to the destination.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate distances from current node to unvisited nodes\n    distances = distance_matrix[current_node, unvisited_nodes]\n    \n    # Calculate the distance from each unvisited node to the destination\n    to_destination = distance_matrix[unvisited_nodes, destination_node]\n    \n    # Calculate the weighted probabilities based on the inverse of the sum of these two distances\n    weights = 1 / (distances + to_destination)\n    weights /= weights.sum()\n    \n    # Select the next node based on the weighted probabilities\n    next_node = np.random.choice(unvisited_nodes, p=weights)\n    \n    return next_node",
          "objective": 22.04609,
          "other_inf": null
     }
]