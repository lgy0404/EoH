[
     {
          "algorithm": "Algorithm: \"Greedy Nearest Neighbor with Dynamic Weight Adjustment\"",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate the distances from the current node to all unvisited nodes\n    distances = distance_matrix[current_node, unvisited_nodes]\n    \n    # Adjust weights dynamically based on the remaining number of unvisited nodes\n    weight_factor = 1 / (len(unvisited_nodes) + 1)\n    adjusted_distances = distances * weight_factor\n    \n    # Select the next node with the smallest adjusted distance\n    next_node = unvisited_nodes[np.argmin(adjusted_distances)]\n    \n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: \"Probabilistic Nearest Neighbor with Adaptive Threshold\"",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate the distances from the current node to all unvisited nodes\n    distances = distance_matrix[current_node, unvisited_nodes]\n    \n    # Calculate the average distance to unvisited nodes\n    avg_distance = np.mean(distances)\n    \n    # Adjust the threshold dynamically based on the average distance\n    threshold = avg_distance * (1 - np.exp(-len(unvisited_nodes) / len(distance_matrix)))\n    \n    # Select the next node probabilistically with a preference for smaller distances\n    probabilities = np.exp(-distances / threshold)\n    probabilities /= np.sum(probabilities)\n    next_node = np.random.choice(unvisited_nodes, p=probabilities)\n    \n    return next_node",
          "objective": 15.19624,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: \"Greedy Randomized Adaptive Search Procedure (GRASP) for TSP\"",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Create a list of candidate nodes with their distances from the current node\n    candidates = [(node, distance_matrix[current_node, node]) for node in unvisited_nodes]\n    \n    # Calculate the lower and upper bound for the restricted candidate list\n    lower_bound = min(candidates, key=lambda x: x[1])[1]\n    upper_bound = max(candidates, key=lambda x: x[1])[1]\n    \n    # Create a restricted candidate list (RCL) with nodes within a random alpha range\n    alpha = random.uniform(0, 1)\n    rcl = [node for node, dist in candidates if lower_bound <= dist <= alpha * (upper_bound - lower_bound) + lower_bound]\n    \n    # Select the next node from the RCL randomly\n    next_node = random.choice(rcl)\n    \n    return next_node",
          "objective": 16.08229,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: \"Probabilistic Weighted Random Selection for TSP\"",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate the probabilities based on the inverse of the distances\n    probabilities = 1 / distance_matrix[current_node, unvisited_nodes]\n    probabilities /= np.sum(probabilities)  # Normalize probabilities\n\n    # Select the next node based on the calculated probabilities\n    next_node = np.random.choice(unvisited_nodes, p=probabilities)\n    \n    return next_node",
          "objective": 18.38329,
          "other_inf": null
     }
]