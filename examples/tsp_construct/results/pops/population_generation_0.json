[
     {
          "algorithm": "Algorithm: \"Greedy Randomized Adaptive Search Procedure (GRASP) for TSP\"",
          "code": "import numpy as np\nimport random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Create a list of candidate nodes with their distances from the current node\n    candidates = [(node, distance_matrix[current_node, node]) for node in unvisited_nodes]\n    \n    # Calculate the lower and upper bound for the restricted candidate list\n    lower_bound = min(candidates, key=lambda x: x[1])[1]\n    upper_bound = max(candidates, key=lambda x: x[1])[1]\n    \n    # Create a restricted candidate list (RCL) with nodes within a random alpha range\n    alpha = random.uniform(0, 1)\n    rcl = [node for node, dist in candidates if lower_bound <= dist <= alpha * (upper_bound - lower_bound) + lower_bound]\n    \n    # Select the next node from the RCL randomly\n    next_node = random.choice(rcl)\n    \n    return next_node",
          "objective": 16.08229,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named \"Adaptive Randomized Greedy\", starts by calculating the shortest distance from the current node to each unvisited node, then selects the next node based on a weighted probability distribution that favors nodes closer to the destination.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # Calculate distances from current node to unvisited nodes\n    distances = distance_matrix[current_node, unvisited_nodes]\n    \n    # Calculate the distance from each unvisited node to the destination\n    to_destination = distance_matrix[unvisited_nodes, destination_node]\n    \n    # Calculate the weighted probabilities based on the inverse of the sum of these two distances\n    weights = 1 / (distances + to_destination)\n    weights /= weights.sum()\n    \n    # Select the next node based on the weighted probabilities\n    next_node = np.random.choice(unvisited_nodes, p=weights)\n    \n    return next_node",
          "objective": 22.04609,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm: Novel \"Probabilistic Greedy\" approach that selects the next node based on a weighted probability distribution derived from the distance to the current node, the distance to the destination node, and a random factor to avoid local minima.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    weights = np.array([distance_matrix[current_node, node] + distance_matrix[node, destination_node] for node in unvisited_nodes])\n    weights += np.random.rand(len(unvisited_nodes))  # Add a random factor\n    weights /= np.sum(weights)  # Normalize to get probabilities\n    next_node = np.random.choice(unvisited_nodes, p=weights)\n    return next_node",
          "objective": 25.26341,
          "other_inf": null
     }
]